=head1 NOMBRE

perlfilter - Filtros de código fuente

=head1 DESCRIPCIÓN

En este artículo se describe una característica de Perl poco conocida, denominada 
I<filtros de código fuente>. Los filtros de código fuente modifican el texto de programa de un módulo antes de que Perl lo vea, de la misma manera que un preprocesador de C modifica el texto del código fuente de un programa C antes de que el compilador lo vea. En este artículo encontrará más información acerca de los filtros de código fuente, su funcionamiento y cómo programar su propio filtro.

The original purpose of source filters was to let you encrypt your
program source to prevent casual piracy. This isn't all they can do, as
you'll soon learn. But first, the basics.

=head1 CONCEPTOS BÁSICOS

Antes de que el intérprete de Perl pueda ejecutar un script Perl, debe leerlo en memoria desde un archivo para analizarlo y compilarlo. Si el script incluye otros scripts mediante una instrucción C<use> o C<require>, el intérprete también tendrá que leer los archivos correspondientes de estos scripts.

Se puede considerar que cada conexión lógica entre el analizador de Perl y un archivo individual es una I<secuencia de código fuente>. Una secuencia de código fuente se crea cuando el analizador de Perl abre un archivo y sigue existiendo mientras el código fuente esté en memoria. Cuando Perl termina el análisis del archivo, destruye la secuencia. Si el analizador de Perl se encuentra una instrucción C<require> o C<use> en una secuencia de código fuente, se crea una secuencia nueva y distinta, exclusiva para ese archivo.

En el diagrama siguiente se representa una única secuencia de código fuente, con el flujo de código fuente de un archivo de script Perl a la izquierda que va hacia el analizador de Perl a la derecha. Perl funciona así normalmente:

    archivo -------> analizador

Debe recordar dos puntos importantes:

=over 5

=item 1.

Aunque puede existir un número arbitrario de secuencias de código fuente en un momento determinado, solo una estará activa.

=item 2.

Cada secuencia de código fuente está asociada con un solo archivo.

=back

Un filtro de código fuente es un tipo especial de módulo Perl que intercepta y modifica una secuencia de código fuente antes de que llegue al analizador. Con el filtro de código fuente, el diagrama cambia:

    archivo ----> filtro ----> analizador

Si esto no le dice nada, considere la analogía de una canalización de comandos. Suponga que tiene un script de shell almacenado en el archivo comprimido I<trial.gz>. El sencillo comando de canalización que se muestra a continuación ejecuta el script sin necesidad de crear un archivo temporal para almacenar el archivo sin comprimir.

    gunzip -c trial.gz | sh

En este caso, el flujo de datos desde la canalización se puede representar de la manera siguiente:

    trial.gz ----> gunzip ----> sh

Los filtros de código fuente permiten almacenar el texto del script comprimido y descomprimirlo para el analizador de Perl:

     comprimido           gunzip
    Programa Perl ---> filtro de código fuente ---> analizador

=head1 UTILIZACIÓN DE FILTROS

¿Cómo se usa un filtro de código fuente en un script Perl? Antes mencionamos que un filtro de código fuente no es más que un tipo especial de módulo. Al igual que todos los módulos Perl, un filtro de código fuente se invoca mediante una instrucción use.

Supongamos que desea pasar el código fuente Perl por un preprocesador de C antes de su ejecución. As it happens///, la distribución de filtros de código fuente incluye un módulo de filtro de preprocesador denominadoFilter::cpp.

A continuación se muestra un programa de ejemplo, C<cpp_test>, que usa este filtro.
Se han agregado números de línea para poder hacer referencia fácilmente a líneas específicas.

    1: use Filter::cpp;
    2: #define TRUE 1
    3: $a = TRUE;
    4: print "a = $a\n";

Al ejecutar este script, Perl crea una secuencia de código fuente para el archivo. Antes de que el analizador proceso cualquiera de las líneas del archivo, la secuencia de código fuente tiene este aspecto:

    cpp_test ---------> analizador

La línea 1, C<use Filter::cpp>, incluye e instala el módulo de filtro C<cpp>. Todos los filtros de código fuente funcionan de esta manera. La instrucción use se compila y se ejecuta en tiempo de compilación, antes de que se lea el resto del archivo y, en segundo plano, asocia/// el filtro cpp a la secuencia de código fuente. Ahora el flujo de datos es así:

    cpp_test ----> filtro cpp ----> analizador

Cuando el analizador lee las demás líneas de la secuencia de código fuente a partir de la segunda, aplica a esas líneas el filtro de código fuente C<cpp> antes de procesarlas. Lo únici que hace el filtro C<cpp> es pasar cada línea por el preprocesador de C real. A continuación, el filtro vuelve a insertar la salida del preprocesador de C en la secuencia de código fuente.

                  .-> cpp --.
                  |         |
                  |         |
                  |       <-'
   cpp_test ----> filtro cpp ----> analizador

El analizador ve el siguiente código:

    use Filter::cpp;
    $a = 1;
    print "a = $a\n";

Veamos qué sucede si el código filtrado incluye otro módulo con la instrucción use:

    1: use Filter::cpp;
    2: #define TRUE 1
    3: use Fred;
    4: $a = TRUE;
    5: print "a = $a\n";

The C<cpp> filter does not apply to the text of the Fred module, only
to the text of the file that used it (C<cpp_test>). Aunque la instrucción use de la línea 3 pasa a través del filtro cpp, el módulo incluido (C<Fred///>) no pasa por el filtro. Después de analizar la línea 3 y antes de antes de analizar la línea 4, la secuencia de código fuente es como sigue:

    cpp_test ---> filtro cpp ---> analizador (INACTIVO)

    ///Fred.pm ----> analizador

Es decir, se ha creado una secuencia nueva para leer el código fuente de C<Fred.pm>. Esta secuencia permanecerá activa hasta que se haya analizado todo el código de C<Fred.pm>. La secuencia de código fuente de C<cpp_test> sigue existiendo, pero está inactiva. Cuando el analizador termina de leer Fred.pm, se destruye la secuencia de código fuente asociada. Entonces la secuencia de código fuente para C<cpp_test> vuelve a activarse y el analizador lee la línea 4
y las demás líneas de C<cpp_test>.

Puede aplicar más de un filtro de código fuente a un solo archivo. De manera similar, puede aplicar un mismo filtro a todos los archivos que desee.

Por ejemplo, si tiene un archivo de código fuente ///uuencoded y comprimido, puede apilar un filtro uudecode y un filtro de descompresión como éste:

    use Filter::uudecode; use Filter::uncompress;
    M'XL(".H<US4''V9I;F%L')Q;>7/;1I;_>_I3=&E=%:F*I"T?22Q/
    M6]9*<IQCO*XFT"0[PL%%'Y+IG?WN^ZYN-$'J.[.JE$,20/?K=_[>
    ...

Una vez procesada la primera línea, el filtro será:

    file ---> uudecode ---> uncompress ---> parser
               filter         filter

Los datos fluyen por el filtor en el mismo orden en que aparecen en el archivo de código fuente. El filtro uudecode aparece antes que el filtro para descomprimir, por lo que se aplicará uudecode al archivo de código fuente antes de descomprimirlo.

=head1 WRITING A SOURCE FILTER

There are three ways to write your own source filter. You can write it
in C, use an external program as a filter, or write the filter in Perl.
I won't cover the first two in any great detail, so I'll get them out
of the way first. Writing the filter in Perl is most convenient, so
I'll devote the most space to it.

=head1 PROGRAMACIÓN DE UN FILTRO DE CÓDIGO FUENTE EN C

La primera de las tres técnicas disponibles consiste en programar el filtro completamente en C. El módulo externo que se crea se comunica directamente con los ///hooks de filtro de código fuente suministrados por Perl.

La ventaja de esta técnica es que ofrece control total de la implementación del filtro. La gran desventaja es que la mayor complejidad que implica programar el filtro (no solo hay que comprender cómo funcionan los ///hooks de filtro de código fuente, sino que también hay que tener un conocimiento sólido de los componentes internos de Perl. Esto supone un gran esfuerzo que se justifica en casos como el desarrollo de un ofuscador/// de código fuente. The
C<decrypt> filter (which unscrambles the source before Perl parses it)
included with the source filter distribution is an example of a C
source filter (see Decryption Filters, below).


=over 5

=item B<Decryption Filters>

All decryption filters work on the principle of "security through
obscurity." Regardless of how well you write a decryption filter and
how strong your encryption algorithm is, anyone determined enough can
retrieve the original source code. The reason is quite simple - once
the decryption filter has decrypted the source back to its original
form, fragments of it will be stored in the computer's memory as Perl
parses it. The source might only be in memory for a short period of
time, but anyone possessing a debugger, skill, and lots of patience can
eventually reconstruct your program.

That said, there are a number of steps that can be taken to make life
difficult for the potential cracker. The most important: Write your
decryption filter in C and statically link the decryption module into
the Perl binary. For further tips to make life difficult for the
potential cracker, see the file I<decrypt.pm> in the source filters
distribution.

=back

=head1 CREACIÓN DE UN FILTRO DE CÓDIGO FUENTE COMO UN EJECUTABLE INDEPENDIENTE

Una alternativa a programar el filtro en C es crear un ejecutable independiente en cualquier otro lenguaje. El archivo ejecutable independiente lee la entrada estándar, realizar las tareas de procesamiento necesarias y escribe los datos filtrados en la salida estándar. C<Filter::cpp> es un ejemplo de filtro de código fuente implementado como un ejecutable independiente; el ejecutable es el preprocesador de C incluido con el compilador de C.

The source filter distribution includes two modules that simplify this
task: C<Filter::exec> and C<Filter::sh>. Both allow you to run any
external executable. Both use a coprocess to control the flow of data
into and out of the external executable. (For details on coprocesses,
see Stephens, W.R., "Advanced Programming in the UNIX Environment."
Addison-Wesley, ISBN 0-210-56317-7, pages 441-445.) The difference
between them is that C<Filter::exec> spawns the external command
directly, while C<Filter::sh> spawns a shell to execute the external
command. (Unix uses the Bourne shell; NT uses the cmd shell.) Spawning
a shell allows you to make use of the shell metacharacters and
redirection facilities.

Here is an example script that uses C<Filter::sh>:

    use Filter::sh 'tr XYZ PQR';
    $a = 1;
    print "XYZ a = $a\n";

The output you'll get when the script is executed:

    PQR a = 1

Writing a source filter as a separate executable works fine, but a
small performance penalty is incurred. For example, if you execute the
small example above, a separate subprocess will be created to run the
Unix C<tr> command. Each use of the filter requires its own subprocess.
If creating subprocesses is expensive on your system, you might want to
consider one of the other options for creating source filters.

=head1 WRITING A SOURCE FILTER IN PERL

The easiest and most portable option available for creating your own
source filter is to write it completely in Perl. To distinguish this
from the previous two techniques, I'll call it a Perl source filter.

To help understand how to write a Perl source filter we need an example
to study. Here is a complete source filter that performs rot13
decoding. (Rot13 is a very simple encryption scheme used in Usenet
postings to hide the contents of offensive posts. It moves every letter
forward thirteen places, so that A becomes N, B becomes O, and Z
becomes M.)


   package Rot13;

   use Filter::Util::Call;

   sub import {
      my ($tipo) = @_;
      my ($ref) = [];
      filter_add(bless $ref);
   }

   sub filter {
      my ($self) = @_;
      my ($estado);

      tr/n-za-mN-ZA-M/a-zA-Z/
         if ($status = filter_read()) > 0;
      $estado;
   }

   1;

All Perl source filters are implemented as Perl classes and have the
same basic structure as the example above.

First, we include the C<Filter::Util::Call> module, which exports a
number of functions into your filter's namespace. The filter shown
above uses two of these functions, C<filter_add()> and
C<filter_read()>.

Next, we create the filter object and associate it with the source
stream by defining the C<import> function. If you know Perl well
enough, you know that C<import> is called automatically every time a
module is included with a use statement. This makes C<import> the ideal
place to both create and install a filter object.

In the example filter, the object (C<$ref>) is blessed just like any
other Perl object. Our example uses an anonymous array, but this isn't
a requirement. Because this example doesn't need to store any context
information, we could have used a scalar or hash reference just as
well. The next section demonstrates context data.

The association between the filter object and the source stream is made
with the C<filter_add()> function. This takes a filter object as a
parameter (C<$ref> in this case) and installs it in the source stream.

Finally, there is the code that actually does the filtering. For this
type of Perl source filter, all the filtering is done in a method
called C<filter()>. (It is also possible to write a Perl source filter
using a closure. See the C<Filter::Util::Call> manual page for more
details.) It's called every time the Perl parser needs another line of
source to process. The C<filter()> method, in turn, reads lines from
the source stream using the C<filter_read()> function.

If a line was available from the source stream, C<filter_read()>
returns a status value greater than zero and appends the line to C<$_>.
A status value of zero indicates end-of-file, less than zero means an
error. The filter function itself is expected to return its status in
the same way, and put the filtered line it wants written to the source
stream in C<$_>. The use of C<$_> accounts for the brevity of most Perl
source filters.

In order to make use of the rot13 filter we need some way of encoding
the source file in rot13 format. The script below, C<mkrot13>, does
just that.

    die "usage mkrot13 filename\n" unless @ARGV;
    my $in = $ARGV[0];
    my $out = "$in.tmp";
    open(IN, "<$in") or die "Cannot open file $in: $!\n";
    open(OUT, ">$out") or die "Cannot open file $out: $!\n";

    print OUT "use Rot13;\n";
    while (<IN>) {
       tr/a-zA-Z/n-za-mN-ZA-M/;
       print OUT;
    }

    close IN;
    close OUT;
    unlink $in;
    rename $out, $in;

If we encrypt this with C<mkrot13>:

    print " hello fred \n";

the result will be this:

    use Rot13;
    cevag "uryyb serq\a";

Running it produces this output:

    hello fred

=head1 USING CONTEXT: THE DEBUG FILTER

The rot13 example was a trivial example. Here's another demonstration
that shows off a few more features.

Say you wanted to include a lot of debugging code in your Perl script
during development, but you didn't want it available in the released
product. Source filters offer a solution. In order to keep the example
simple, let's say you wanted the debugging output to be controlled by
an environment variable, C<DEBUG>. Debugging code is enabled if the
variable exists, otherwise it is disabled.

Two special marker lines will bracket debugging code, like this:

    ## DEBUG_BEGIN
    if ($year > 1999) {
       warn "Debug: millennium bug in year $year\n";
    }
    ## DEBUG_END

The filter ensures that Perl parses the code between the <DEBUG_BEGIN>
and C<DEBUG_END> markers only when the C<DEBUG> environment variable
exists. That means that when C<DEBUG> does exist, the code above
should be passed through the filter unchanged. The marker lines can
also be passed through as-is, because the Perl parser will see them as
comment lines. When C<DEBUG> isn't set, we need a way to disable the
debug code. A simple way to achieve that is to convert the lines
between the two markers into comments:

    ## DEBUG_BEGIN
    #if ($year > 1999) {
    #     warn "Debug: millennium bug in year $year\n";
    #}
    ## DEBUG_END

Here is the complete Debug filter:

    package Debug;

    use strict;
    use warnings;
    use Filter::Util::Call;

    use constant TRUE => 1;
    use constant FALSE => 0;

    sub import {
       my ($tipo) = @_;
       my (%context) = (
         Enabled => defined $ENV{DEBUG},
         InTraceBlock => FALSE,
         Filename => (caller)[1],
         LineNo => 0,
         LastBegin => 0,
       );
       filter_add(bless \%contexto);
    }

    sub Die {
       my ($self) = shift;
       my ($mensaje) = shift;
       my ($line_no) = shift || $self->{LastBegin};
       die "$message at $self->{Filename} line $line_no.\n"
    }

    sub filter {
       my ($self) = @_;
       my ($estado);
       $estado = filter_read();
       ++ $self->{LineNo};

       # deal with EOF/error first
       if ($status <= 0) {
           $self->Die("DEBUG_BEGIN has no DEBUG_END")
               if $self->{InTraceBlock};
           return $estado;
       }

       if ($self->{InTraceBlock}) {
          if (/^\s*##\s*DEBUG_BEGIN/ ) {
              $self->Die("Nested DEBUG_BEGIN", $self->{LineNo})
          } elsif (/^\s*##\s*DEBUG_END/) {
              $self->{InTraceBlock} = FALSE;
          }

          # comment out the debug lines when the filter is disabled
          s/^/#/ if ! $self->{Enabled};
       } elsif ( /^\s*##\s*DEBUG_BEGIN/ ) {
          $self->{InTraceBlock} = TRUE;
          $self->{LastBegin} = $self->{LineNo};
       } elsif ( /^\s*##\s*DEBUG_END/ ) {
          $self->Die("DEBUG_END has no DEBUG_BEGIN", $self->{LineNo});
       }
       return $estado;
    }

    1;

The big difference between this filter and the previous example is the
use of context data in the filter object. The filter object is based on
a hash reference, and is used to keep various pieces of context
information between calls to the filter function. All but two of the
hash fields are used for error reporting. The first of those two,
Enabled, is used by the filter to determine whether the debugging code
should be given to the Perl parser. The second, InTraceBlock, is true
when the filter has encountered a C<DEBUG_BEGIN> line, but has not yet
encountered the following C<DEBUG_END> line.

If you ignore all the error checking that most of the code does, the
essence of the filter is as follows:

    sub filter {
       my ($self) = @_;
       my ($estado);
       $estado = filter_read();

       # deal with EOF/error first
       return $status if $status <= 0;
       if ($self->{InTraceBlock}) {
          if (/^\s*##\s*DEBUG_END/) {
             $self->{InTraceBlock} = FALSE
          }

          # comment out debug lines when the filter is disabled
          s/^/#/ if ! $self->{Enabled};
       } elsif ( /^\s*##\s*DEBUG_BEGIN/ ) {
          $self->{InTraceBlock} = TRUE;
       }
       return $estado;
    }

Be warned: just as the C-preprocessor doesn't know C, the Debug filter
doesn't know Perl. It can be fooled quite easily:

    print <<EOM;
    ##DEBUG_BEGIN
    EOM

Such things aside, you can see that a lot can be achieved with a modest
amount of code.

=head1 CONCLUSIÓN

You now have better understanding of what a source filter is, and you
might even have a possible use for them. If you feel like playing with
source filters but need a bit of inspiration, here are some extra
features you could add to the Debug filter.

First, an easy one. Rather than having debugging code that is
all-or-nothing, it would be much more useful to be able to control
which specific blocks of debugging code get included. Try extending the
syntax for debug blocks to allow each to be identified. The contents of
the C<DEBUG> environment variable can then be used to control which
blocks get included.

Once you can identify individual blocks, try allowing them to be
nested. That isn't difficult either.

Here is an interesting idea that doesn't involve the Debug filter.
Currently Perl subroutines have fairly limited support for formal
parameter lists. You can specify the number of parameters and their
type, but you still have to manually take them out of the C<@_> array
yourself. Write a source filter that allows you to have a named
parameter list. Such a filter would turn this:

    sub MySub ($first, $second, @rest) { ... }

en esto:

    sub MySub($$@) {
       my ($first) = shift;
       my ($second) = shift;
       my (@rest) = @_;
       ...
    }

Finally, if you feel like a real challenge, have a go at writing a
full-blown Perl macro preprocessor as a source filter. Borrow the
useful features from the C preprocessor and any other macro processors
you know. The tricky bit will be choosing how much knowledge of Perl's
syntax you want your filter to have.

=head1 THINGS TO LOOK OUT FOR

=over 5

=item Some Filters Clobber the C<DATA> Handle

Some source filters use the C<DATA> handle to read the calling program.
When using these source filters you cannot rely on this handle, nor expect
any particular kind of behavior when operating on it.  Filters based on
Filter::Util::Call (and therefore Filter::Simple) do not alter the C<DATA>
filehandle.

=back

=head1 REQUIREMENTS

The Source Filters distribution is available on CPAN, in 

    CPAN/modules/by-module/Filter

Starting from Perl 5.8 Filter::Util::Call (the core part of the
Source Filters distribution) is part of the standard Perl distribution.
Also included is a friendlier interface called Filter::Simple, by
Damian Conway.

=head1 AUTOR

Paul Marquess E<lt>Paul.Marquess@btinternet.comE<gt>

=head1 COPYRIGHTS

This article originally appeared in The Perl Journal #11, and is
copyright 1998 The Perl Journal. It appears courtesy of Jon Orwant and
The Perl Journal.  Puede distribuir este documento en los mismos términos que Perl.
